bst = BST
avltree = AVL tree
btree = B tree
redblack = Red-black tree
aatree = AA tree
skiplist = Skiplist
maxheap = Max Heap
minheap = Min Heap
treap = Treap
scapegoat = Scapegoat tree
splaytree = Splay tree

display = Display
control = Control
text = Text
next = Next
clear = Clear
random = Random
pause = Pause
small = Small
insert = Insert
find = Find
delete = Delete
insertion = Insertion
search = Search
deletion = Deletion
splay = Splay

size = Size
height = Height
opt = opt
avedepth = Ave. depth
nodes = Nodes
keys = Keys
full = full
excess = Excess nodes
deleted = Deleted
emptyheap = heap is empty
fullheap = heap is full

done = That's it.
empty = The tree is empty.
alreadythere = The key is already in the tree.
found = Found.
notfound = Not found.
newroot = The tree is empty so we make a new root.

size = Size: #1
bstinsertstart = We start at the root.
bstinsertleft = Since #1 &lt; #2, we insert it in the left subtree.
bstinsertright = Since #1 &gt; #2, we insert it in the right subtree.
bstfindstart = We start searching at the root.
bstfindleft = Since #1 &lt; #2, we search the left subtree.
bstfindright = Since #1 &gt; #2, we search the right subtree.
bstdeletestart = First we have to find the node.
bstdeletecase1 = Case I: The node is a leaf; we can delete it.
bstdeletecase2 = Case II: The node has one son; we link the son to node's father and then delete it.
bstdeletecase3 = Case III: The node has two sons; we find it's successor which will replace it. (Successor is the leftmost node in the right subtree - this has at most one son and we can delete it easily.)

avlinsertbal = Node has been inserted. We go back and update the balance information.
avldeletebal = Node has been deleted. We go back and update the balance information.
avlupdatebal = We update the balance information.
avll = Right subtree is too high: We perform a left rotation.
avlr = Left subtree is too high: We perform a right rotation.
avlrl = Right subtree is too hight, but its left subtree is higher than the right one: We perform a right-left rotation.
avllr = Left subtree is too high, but its right subtree is higher that the left one: We perform a left-right rotation.

bfind0 = #1 &lt; #2, we go along the 1. link.
bfind = #1 &lt; #2 &lt; #3, we go along the #4. link.
bfindn = #1 &lt; #2, we go along the #3. link.
binsertleaf = We insert the key into this node.
bsplit = The node is too big, we have to split it.
bdelete1 = Case I: The key is in a leaf; we can delete it.
bdelete2 = Case II: The key is in an internal node; we replace it by its successor.
bleft = Case I: The node is too small, but its left brother is big enough so we can take one key from it.
bright = Case II: The node is too small, but its right brother is big enough so we can take one key from it.
bmerge = Case III: The node is too small and so is its brother, so we merge them.

rbinsertcase1 = Case I, red uncle: We color the father and uncle black, the grandfather red and continue from grandfather.
rbinsertcase2 = Case II, black uncle, "inner" vertex: We transform this to Case III.
rbinsertcase3 = Case III, black uncle "outer" vertex: We perform a rotation and recolor the nodes.
rbdelete1 = Case I: Node's sibling is red: We recolor some nodes and transform it to Case II, III, or IV.
rbdelete2 = Case II: Node's sibling and both his children are black: the extra black is moved up the tree.
rbdelete3 = Case III: Node's sibling is black, the closer child is red, the next one is black: We transform it to Case IV.
rbdelete4 = Case IV: Node's sibling and his child closer to us is black, the other one is red: By some recoloring and one rotation we can remove the extra black.

aaok = This node is OK.
aaskew = Skew: Left subtree has the same rank; we perform a right rotation.
aaskew2 = Skew2: Left subtree has the same rank; we perform a right rotation.
aaskew3 = Skew3: Left subtree has the same rank; we perform a right rotation.
aasplit = Split: The pseudonode (nodes of equal rank) is too big; we perform a left rotation and promote the middle node.
aasplit2 = Split2: The pseudonode (nodes of equal rank) is too big; we perform a left rotation and promote the middle node.

skipinsertstart = We start at the top left corner and find appropriate place to insert the new node.
skipinsertnext = Next key is less than our key. We insert it right.
skipinsertafter = We insert the new node right after this one.
skippromote = We toss a coin. It came up heads so we promote the node.
skipend = We toss a coin. It came up tails so we stop.
skipnext = Next key is less than our key. We go right.
skipdown = Next key is greater or equal. We go down.
skipfindstart = We start searching at the top left corner.
skipdelete = Now we delete the node from each level.

heapbubbleup = We bubble the node up (swap it with its parent) until its parent has greater priority.
heapbubbledown = We bubble the node down (swap it with its greater child) until it is greater than both of its children.

treapbubbleup = We bubble the node up until its parent has greater priority.
treapbubbledown = We bubble the node down.
treapdeletecase1 = Now the node is a leaf and we can simply delete it.

deletemax = Delete Maximum
deletemin = Delete Minimum
heapempty = The heap is empty.
heapfull = The heap is full.

gbinsertunmark = The key is already in the tree but marked as deleted. We just unmark it.
gbtoohigh = This subtree is too high. We rebuild the whole subtree.
gbrebuild1 = Phase I: We transform the subtree into a linear list and delete the nodes marked for deletion.
gbrebuild2 = Phase II: We transform the list into a perfectly balanced tree.
gbfinddeleted = The node has been deleted. Not found.
gbdeletemark = We mark the node for deletion (we will delete when we rebuild the subtree).
gbdeletedeleted = The node has been already deleted.
gbdeleterebuild = Half of the nodes has been marked for deletion. We rebuild the whole tree.

splaystart = First we find the key or the smallest bigger key or the biggest smaller key and splay it to the root.
splayfound = We splay this node.
splayroot = There is no grandparent; we just rotate.
splayzigzigleft = Zig-zig case (parent and grandparent are to the right): we first rotate the parent and then the node.
splayzigzigright = Zig-zig case (parent and grandparent are to the left): we first rotate the parent and then the node.
splayzigzagleft = Zig-zag case (parent is to the right and grandparent to the left): we rotate the node twice.
splayzigzagright = Zig-zag case (parent is to the left and grandparent to the right): we rotate the node twice.
splayinroot = Now our key, smallest bigger or biggest smaller is in the root.
splayinsertleft = Now the root and its left subtree is less than our key and root's right subtree is greater than our key: we just make a new root and link the current root left and it's right subtree right.
splayinsertright = Now the root and its right subtree is greater than our key and root's left subtree is less than our key: we just make a new root and link the current root right and it's left subtree left.
splaydeleteleft = The root has no right subtree; we just delete it and make the left child the new root.
splaydeleteright = The root has no left subtree; we just delete it and make the right child the new root.
splaydelete = We delete the root, splay the right subtree for minimum.
splaydeletelink = The minimum of the right tree will be the new root; since minimum has no left son, we can just link the left tree.
